# 메모리 관리

- 메모리 관리의 이유
  - 현대의 프로그램은 우선 메모리에 적재 후 여러 프로세스를 돌리는데, 한정된 메모리를 여러 프로세스가 사용하기 위해서 효율적인 관리가 필요하기 때문에
- 메모리 관리란?
  - 프로세스들을 위해서 메모리를 할당하고 제거하며 보호하는 활동
  - 프로세스의 요청에 따라 메모리를 할당하고 해제하는 과정
  - 프로그램을 실행하기 전에 메모리를 적재하는 것도 포함
- 메모리 관리는 메모리 관리자가 담당하는데, 운영체제의 관리 모듈과 MMU, Memory Management Unit 이 서로 협업하여 관리
- 메모리 관리의 3가지 정책이 있음
  1. 적재 정책, fetch policy : 디스크 -> 메모리 반입
  2. 배치 정책, placement policy : 반입한 프로세스를 어디에 위치시킬 것인가
  3. 대치 정책, replacement policy : 메모리가 충분하지 않을 때 어떻게 교체할 것인가

# 메모리의 구조와 매핑

- 메모리 : 주소 공간의 연속으로 물리적 주소를 다루기 위해 사용자는 논리적 주소를 이용하고 MMU가 Address Binding 수행
  - 물리적 주소
    - 메모리 Unit 의 실제 주소
    - 사용자가 접근 불가
    - 논리 주소에 매핑된 실제 주소 집합
  - 논리적 주소
    - CPU가 생성한 가상 주소
    - 사용자가 접근 가능
    - 논리 주소를 이용해서 논리 주소로 접근
    - 고수준 언어에서의 변수를 생성하는 것
  - 주소 바인딩
    - Address Binding 혹은 Mapping
    - MMU가 처리 (고정 분할, 동적 분할, 페이징, 세그멘테이션, Paged 세그멘테이션 방법 적용)

# 바인딩 분류

- 논리적 주소를 물리적 주소로 변환하는 시점에 따라 용어를 나눌 수 있음
  - 컴파일 시간, 적재 시간, 실행 시간으로 구분가능
- 컴파일 시간
  - 프로세스가 메모리에 적재될 위치를 컴파일 과정에서 알 수 있다면 물리 주소를 생성 가능
